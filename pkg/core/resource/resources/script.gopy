import bpy
import sys
import ast
import os
import argparse
import logging
import addon_utils

from pathlib import Path
from logging.handlers import RotatingFileHandler

if not os.path.exists("logs"):
    os.makedirs("logs")

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s %(message)s',
    datefmt='%a, %d %b %Y %H:%M:%S',
    handlers=[
        RotatingFileHandler(
            "logs/rocketblend.log",
            mode="a",
            maxBytes=5*1024*1024,
            backupCount=2,
            encoding=None,
            delay=0
        ),
        logging.StreamHandler()
]) 

log = logging.getLogger(__name__)

# This is the script that is run when Blender is started from the CLI.
# It is used to load the addons specified in the command line.
# The script is called with the following arguments:
# -a, --addons: a comma-separated list of addons to load.
#               The addons must be specified as a dict with the name of the package 
#               and a  path to the addon's directory.
#               E.g., -a "{"addon1": "C:\Users\user\Documents\blender\addons\addon1",
#                          "addon2": "C:\Users\user\Documents\blender\addons\addon2"}"
#               If the addon is already installed on this build, it will be
#               loaded. Otherwise, it will be installed and then loaded.

class ArgumentParserForBlender(argparse.ArgumentParser):
    """
    This class is identical to its superclass, except for the parse_args
    method (see docstring). It resolves the ambiguity generated when calling
    Blender from the CLI with a python script, and both Blender and the script
    have arguments. E.g., the following call will make Blender crash because
    it will try to process the script's -a and -b flags:
    >>> blender --python my_script.py -a 1 -b 2

    To bypass this issue this class uses the fact that Blender will ignore all
    arguments given after a double-dash ('--'). The approach is that all
    arguments before '--' go to Blender, arguments after go to the script.
    The following calls work fine:
    >>> blender --python my_script.py -- -a 1 -b 2
    >>> blender --python my_script.py --
    """

    def _get_argv_after_doubledash(self):
        """
        Given the sys.argv as a list of strings, this method returns the
        sublist right after the '--' element (if present, otherwise returns
        an empty list).
        """
        try:
            idx = sys.argv.index("--")
            return sys.argv[idx+1:] # the list after '--'
        except ValueError as e: # '--' not in the list:
            return []

    # overrides superclass
    def parse_args(self):
        """
        This method is expected to behave identically as in the superclass,
        except that the sys.argv list will be pre-processed using
        _get_argv_after_doubledash before. See the docstring of the class for
        usage examples and details.
        """
        return super().parse_args(args=self._get_argv_after_doubledash())

class Startup():
    """
    This class is called at Blender startup, and is used to install/enable the
    addons specified by the command line argument.
    """

    default_addons = [
        "io_anim_bvh",
        "io_curve_svg",
        "io_mesh_ply",
        "io_mesh_stl",
        "io_mesh_uv_layout",
        "io_scene_fbx",
        "io_scene_gltf2",
        "io_scene_obj",
        "io_scene_x3d",
        "node_wrangler",
        "cycles"
    ]

    custom_addons = {}
    
    def __init__(self, addons: dict[str, str]):
        logging.debug(f"Starting Blender with the following addons: {addons}")

        for name, path in addons.items() or {}:
            pth = Path(path)
            if pth.exists():
                self.custom_addons[name] = str(pth)

        self.install_custom_addons()
        self.reset_addons()

        logging.debug(f"Finished loading addons")

    def install_custom_addons(self, overwrite: bool = False) -> None:
        """
        Installs any addon not already installed on this build.
        """
        installed = []

        for mod in addon_utils.modules():
            if mod.__name__ in self.custom_addons:
                installed.append(mod.__name__)

        for addon, path in self.custom_addons.items():
            if addon not in installed:
                logging.debug(f"Installing addon {addon} from {path}")
                bpy.ops.preferences.addon_install(filepath=path, overwrite=overwrite)

    def reset_addons(self) -> None:
        """
        Resets addons to only the enabled ones.
        """  
        enable = self.default_addons + list(self.custom_addons.keys())

        for addon in bpy.context.preferences.addons:
            if addon.module not in enable:
                self.disable_addon(addon)
            else:
                enable.remove(addon.module)

        for addon in enable:
            self.enable_addon(addon)

    def enable_addon(self, addon: str) -> None:
        """
        Enables the addon with the given name.
        """
        mod = addon_utils.enable(addon, default_set=True)

        if mod:
            logging.debug(f"Enabled addon {addon}")

            info = addon_utils.module_bl_info(mod)
            info_ver = info.get("blender", (0, 0, 0))

            if info_ver > bpy.app.version:
                logging.debug(f"Addon {addon} was written in Blender {info_ver[0]}.{info_ver[1]} and may not work correctly in Blender {bpy.app.version[0]}.{bpy.app.version[1]}")
        else:
            logging.debug(f"Failed to enable addon {addon}")

    def disable_addon(self, addon: str) -> None:
        """
        Disables the addon with the given name.
        """
        addon_utils.disable(addon)
        logging.debug(f"Disabled addon {addon}")

    def err_cb(ex):
        logging.error(f"An error occurred with the addon: {ex}")

parser = ArgumentParserForBlender()
parser.add_argument("-a", "--addons", help="Addons to load", type=ast.literal_eval, default={})

args = parser.parse_args()

Startup(args.addons)